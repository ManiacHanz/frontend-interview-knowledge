
### http1.1时如何复用tcp连接

头里有个`Connection`配置成`keep-alive`的选项，在一个`TCP`连接中可以进行多个`HTTP`请求，可以减少客户端和服务器连接时3次握手的消耗


### 简介service worker

[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API)
[腾讯AlloyTeam博文](http://www.alloyteam.com/2016/01/9274/)

> Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。

**只能基于HTTPS使用**

使用场景
* 后台消息传递
* 网络代理，转发请求，伪造响应
* 离线缓存
* 消息推送
* … …


### Http报文的请求会有几个部分

HTTP 报文是简单的格式化数据块。每条报文都包含一条请求或者响应。它们由三个部分组成：对报文进行描述的起始行（start line）、包含属性的头部（header）块，以及可选的，包含数据的主体（body）部分。

* 起始行：请求方法，请求URL，状态码等描述信息
* 头部： 请求头和响应头，对信息进行补充，比如`Content-type`,`Accept`等
* 主体： 传输的数据，文件等


### cookie放哪里，cookie能做的事情和存在的价值

cookie放在硬盘上，每次浏览器请求的时候会去硬盘上检查时候有相同域下的cookie，有就带上一起发给服务端

cookie可以当成一种标识，让服务端统计和区别新老访客；HTTPonly可以用来做登录id


### TCP

TCP(Transmission Control Protocol) 传输控制协议。位于第四层传输层。

TCP 五层 1 物理层 -> 2 数据链路层 -> 3 网络层(ip)-> 4 传输层(tcp) -> 5 应用层(http)

三次握手，四次握手 [更多知识](https://yuchengkai.cn/docs/zh/cs/#tcp)

Sync 同步序号，请求连接时Syn的位置为1
seq number 顺序序号： 用来表示报文段中的第一个数据字节在数据流中的位置，避免网络报文乱序
ack number 确认序号： 收到请求后返回的确认序号，通常是seq+1，也代表了期望收到的下一个报文的序号


客户端首先发送 syn包
服务端接受后确认， 返回syn/ack包 (acknowledgement)。ack是一个确认的机制。也用seq+1的方式确认对应
客户端接收后确认，并发送ack包，此时服务端收到请求以后就会打开通路

三次握手的目的是**让客户端控制打开服务器的时机**。因为网络阻塞的情况下，客户端可能发送多次握手请求，这时服务端会对应的返回多次确认时机，如果没有第三次，就开了多余的服务端口。而有了第三次确认，客户端会从服务端返回的消息中，发现其中是重复的，所以就会抛弃重复的部分，进行正确的通信

四次挥手

| UDP | TCP |
| 不建立连接 | 建立连接 |
| 数据传输有限制 | 数据传输无限制 |
| 速度快，可靠性差 | 速度慢，可靠性高 |



### BASE64的优缺点

优点：
* 把图片变成了`base64`以后可以减少`network`里的请求次数，也减少并发请求量
* 没有缓存，所以不需要解决缓存问题

缺电：
* 没有缓存，使得在很多常驻的图片下不适用，也包括常驻的字体文件
* 如果背景图片过多的使用`base64`的图片，意味着`css`文件会很臃肿，而`css`的文件的加载时间是会阻滞页面的渲染，导致用户的白屏时间更长。同时对`Gzip`的支持也不是很好


### HTTP和HTTPS解析

HTTPS解决了三个问题：数据加密，服务器身份信息验证，数据完整性验证
1. 数据加密： 使用非对称加密生产公钥，使用对称加密公钥来加密数据
2. 身份信息： 通过证书来验证服务端身份。客户端向服务端请求时，服务端会下发证书CA。客户端会通过非对称里的公钥对ca重的密文进行解密，然后对比CA中的信息，如果一致就是身份验证通过
3. 数据完整性： 校验发送的数字签名的完整性。发送者通过hash对内容加密生成摘要，再把摘要通过私钥生成数字签名；接受者反过来听过公钥解密，然后把内容通过同样的hash函数生成摘要，对比摘要的相同与否。核心： 对比内容通过hash函数生成的摘要的相同不同

来自[掘金](https://juejin.im/post/5c1913a46fb9a049db73119a)


### 说下浏览器缓存、DNS缓存、nginx缓存、服务端缓存的区别；强缓存和 协商缓存的应⽤
浏览器缓存分为强缓存和协商缓存，主要是由请求报文中的字段控制。缓存后的文件除了写入硬盘，一般浏览器执行后的js文件或者图片会被写入内存，比如说第一次打开某被缓存网页，其中所有文件都是`from disk cache`，然后此时刷新网页，js文件和图片文件会变成`from memory cache`，而css文件还是会从硬盘里读取

强缓存控制的字段主要是`expire`和`cache-control`。
* expire字段主要是在http1.0中使用，记录的是缓存过期的**绝对**时间。比对的时候是客户端和服务端的时间对比，所以不够准确
* cache-control 可用用于http1.1（现在浏览器默认支持）。其中的max-age同样可以记录过期的**相对**时间，优先级高于expire

协商缓存控制的字段主要是`etag/if-none-match`和`if-modified-since/last-modified`两组字段控制。逻辑大致相同，由客户端请求文件的时候在请求头里带上上次获取的缓存标识，服务端拿到这个标识和文件做对比，缓存生效则返回304让客户端从缓存中读取，如果不生效就返回新的文件和新的标识。`etag`优先级高于后者
* etag/if-none-match。是由服务端生成的标识。一致的时候标识无更新
* if-modified-since/last-modified。表示服务端的文件时间，服务端会受到if-modified-since的时间和文件变更时间做对比

DNS缓存
把访问过网站的url和对应的ip记录下来，下次就不需要去访问运营商服务器获取ip地址了


### http1.0 http1.1 http2.0

http1.0  特点：短连接。每次启动都必须启动一个TCP链接，链接无法复用。所以瓶颈就是TCP协议的三次握手消耗以及慢启动消耗

http1.1  特点：持久链接，可以复用一个TCP链接。复用方法，通过请求/响应头中的connection标记为keep-alive来控制。同时，比1.0更好的地方有，更好的缓存控制，cache-control替代expire；更好的带宽优化，一个请求未结束时，可以发送下一个请求；同时还增加了身份认证、状态管理等请求头
但是持久链接有阻塞现象，比如在一个持久链接中，上一个请求没收到返回时，不能再次发送下一个请求

http2.0  特点：多路复用，服务端发推送，二进制分帧，首部压缩。多路复用指，2.0把协议通信的最小单位变为了帧，这些帧可以在一个连接上双向交换信息；服务端推送指，服务器可以对一个请求发送多次响应；二进制分帧指，2.0在应用层和传输层中间加入了一个二进制分帧层，头部信息放入HEADER frame，body放入BODY frame，并且用二进制取代了以前的文本；首部压缩是换了报文的压缩算法

2.0仍然是建立在TCP协议上，所以如果丢包，整个TCP都要开始等待重传，就会阻塞该TCP连接的其他请求

2.0的头部压缩算法大致如下：
1. 常用的字段直接通过静态map去对应。比如method: get。压缩后可能就是一个数字2
2. 动态的但是会复用的字段通过动态map去保存，比如userAgent，在第一次传输过去以后，后面的都按照表的对应去传，比如数组62 63
3. 以上两种都不满足，即不常用又是经常变化的字段，直接采用Huffman算法压缩。（利用贪心算法压缩文本。 把各个字符以及出现的次数进行升序排序，然后生成一颗二叉树，最后按照二叉树的路径给每个字符编码，形成一个字典） [huffman算法解释](https://coolshell.cn/articles/7459.html)

谈谈多路复用

http2.0能多路复用主要是基于二进制分帧的技术。

http1.1主要使用的是文本分割。我们在浏览器中看到的报文都是文本，服务器需要边接收边解析，以换行符分割每一条的key:value的内容，所以这种解析往往比较慢，而且容易出错

而http2.0使用了二级制帧这样的数据单元，把发送的数据分成了更小的格式单位。实现了对消息的封装，以及可以预知，可控制的目的

首先来说，帧里面有length, type, flags(帧标识)等标识帧的基本信息。同时还有关键的stream id(流id)用来保证帧的不错乱。其中type字段里又有不同的标识符，能够为多路复用提供多种功能，比如DATA和HEADER都是常用的数据体和数据头。*PRIORITY*标识权重，可以改变数据流的优先级和依赖；*WINDOW_UPDATE*可以用来协商一方要接收多少字节，实现流量控制；还有*PUSH_PROMISE*用来告诉客户端服务端要主动推送一些东西；

所谓的流： HTTP2连接中独立的、双向的帧序列交换

### 网络模型

七层：物数网传会表应(*p*lease *d*o *n*ot *t*ell *s*tupid *p*eople *a*nything)

物理层：
数据链路层：
网络层：IP
传输层：TCP、UDP协议 。 提供端对端接口
会话层：
表式层：
应用层：HTTP协议。向用户提供应用协议


### 扫码登录流程

客户端跳转登录页面，向服务端发起请求，获取登录二维码。其中带有标识，和redirectUrl，然后开启轮询，判断是否登录成功

手机端由于已经已经登录，在扫码后就会带着用户token去请求服务器。服务器收到以后去库里对照，然后生成Jwt返回给客户端那边，完成登录流程


### Cookie属性

http-only：不能使用js操作cookie
secure: 只能使用https协议才能发送cookie
same-site: 指cookie的作用域和上下文的限制。None: 所有上下文和跨域中可发送。必须secure。Lax允许与顶级导航一起发送，并将于第三方网站的get请求一起发送。Strict: 只在第一方上下文中发送，不在第三方网站中发送。*same-site的引入是为了解决csrf攻击*

### 安全

XSS: cross-site scripting 跨域脚本攻击
  主要是通过输入框输入<script>标签作为脚本，直接攻击服务器，或者输出内容等另外用户访问时变成攻击，或者是jsonp中callback恶意使用script标签 
  
  分为存储型和反射型。存储型主要是存储到服务器数据库中，反射型是通过url参数传递。防范核心思想主要是通过转义，把可能直接插入到html中的 -- 包括用户生成的内容、路由参数等等 -- 内容中的关键词过滤掉之后再放到html中


CSRF：cross-site request forgery 跨域请求伪造
  名字可以看出，是不同域下的请求伪造，危害主要来自带有权限token以后伪造的用户请求，所以需要same-site


### 首屏秒开的几种方案

> 所有所谓的性能优化，首先应该去考虑有什么样的性能瓶颈，针对瓶颈去进行优化

* 懒加载
  主要是为了解决静态资源过慢的问题。页面中除了少量的数据请求外，大部分的请求都在于对静态资源的请求。懒加载主要的目的是把首屏以外的静态资源放在后面请求，也就是说可以以常用的屏幕大小大致计算出需要的请求的静态资源数量，然后把剩余的都按照懒加载下拉/滚动的方案处理

* 缓存
  主要是分为**接口缓存**和**静态资源缓存**。缓存的目的，主要是减少重复的请求。
  接口缓存：主要是对数据的缓存，或者是对请求时机的优化。前者比如说是利用客户端本地的储存方式，把数据提前存起来，或者是内存中；后者比如说，在native场景中，一般的请求需要先请求页面及脚本，然后才执行数据的请求，这里是串行的请求方式，我们可以通过sdk，利用native本身，请求webview中需要的数据，然后再通过通信机制交给webview处理，相当于把串行的执行机制改成了并行的执行机制。
  静态资源缓存：这个应该是缓存的主要目的了。通过强缓存和协商缓存进行优化


* 离线化
  把首屏的页面通过提前打包的形式保存在本地，可以理解成一个本地的ssr页面

  这里有一个方案，利用webpack插件`prerender-spa-plugin`，把需要的路由地址缓存在本地，打包出来可以看到是一个有内容的`html`文件。这样可以处理首屏过慢，或者是ssr服务器遇到高并发的问题


* 并行化
  这个痛点主要是在tcp/ip链接以及http协议上
  首先就是解决tcp/ip的握手及慢启动阻塞，这个方法就是http1.1的keep-alive去保持长连接。但是http1.1有它的痛点：*同域名请求数量限制*以及*串行请求--服务端不能主动推送*。所以可以使用http2.0的多路复用机制。在不能使用2.0的情况下，还有个方案就是同域名的请求数量限制可以去把不同的资源分到不同的域名下去请求，但是这里又会出现`dns解析`时间的增加

* DNS查询优化
  核心方案是浏览器标签自带的代码

  ```html
  <meta http-equiv="x-dns-prefetch-control" content="on" />
  <link rel="dns-prefetch" href="https://s.google.com/" >
  ```

  在嵌入时可以在首页通过肉眼不可见的iframe，或者webview，提前去把后续需要解析的dns全部一次性解析完毕

* 骨架屏
  动态骨架屏：确定生成规则/策略，遍历所有dom元素，然后针对特定区块（视频、音频）去生成响应的代码块，获取页面中DOM的宽度和高度，以及视窗的距离，然后放到页面中展示。这里通过node去读取页面大概布局可以使用一个node包 -- `puppeteer`。 [饿了么骨架屏方案分享](https://github.com/Jocs/jocs.github.io/issues/22)。 方案概括

  > 通过 puppeteer 在服务端操控 headless Chrome 打开开发中的需要生成骨架屏的页面，在等待页面加载渲染完成之后，在保留页面布局样式的前提下，通过对页面中元素进行删减或增添，对已有元素通过层叠样式进行覆盖，这样达到在不改变页面布局下，隐藏图片和文字，通过样式覆盖，使得其展示为灰色块。然后将修改后的 HTML 和 CSS 样式提取出来，这样就是骨架屏了。


### 正向代理和反向代理

正向代理：是指客户端知道服务端是哪，指定代理服务器去请求服务端，然后把服务端数据返回给客户端。这个过程相当于隐藏了*客户端*的身份。 -- 科学上网

反向代理：指客户端就像指定服务器发送请求，但是这个服务器其实是一个代理服务器，它会根据用户的请求去处理往哪里的真正的服务器去发送请求。这个过程相当于隐藏了*服务端*的身份 -- nginx, 本地开发

### GET和POST区别

要说到主要是在浏览器的上下文中，get没有请求体（会被自动屏蔽），url传参有长度限制。

### 状态码

200

204

206

301

302

304

400

401

403

404

500

502


### DNS解析大致流程

分两步：*找缓存*和*递归查询*

1. 找缓存分为四步： 浏览器缓存，本地hosts文件缓存， 路由器缓存，已经isp dns服务器缓存。如果这四步都没有，就走到查询规则里
2. 递归查询： 首先会去请求根域名对应的服务器，服务器会将顶级域名对应的服务器ip返回，然后本地DNS服务器再去请求顶级域名服务器ip获取二级域名服务器ip.依次递归


### 传统的网络通讯步骤

上面这个过程和传统网站的请求响应过程类似，一般经历以下步骤：

用户在自己的浏览器中输入要访问的网站域名。

浏览器向本地DNS服务器请求对该域名的解析。

本地DNS服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。

本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以迭代方式向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。

浏览器得到域名解析结果，就是该域名相应的服务设备的IP地址 。

浏览器获取IP地址之后，经过标准的TCP握手流程，建立TCP连接。

浏览器向服务器发起HTTP请求。服务器将用户请求内容传送给浏览器。

经过标准的TCP挥手流程，断开TCP连接。


### CDN

先把cdn粗浅的理解成在dns解析的时候，会被解析到一个CDN专用的DNS服务器，然后会得到一个负责全国CDN负载均衡的服务器的Ip，由这个ip根据用户的网络情况和地理位置来分发具体的cdn地址

### TCP/IP

IP协议不可靠，主要表现为三个方面： 冲突丢包，传输错误，被篡改
TCP解决办法：丢包采用ACK确认序号来让客户端知道丢包了，能够重发。缺点是效率更慢；~~checksum确保被篡改（不可靠）~~

背诵：
  确认和重传机制
  数据校验
  数据分片和排序
  流量控制
  拥塞控制
